a) Worst-case runtime for somefunc is O(n^2) because although bar is run only when this->n and this->max are equal, this->n is being incremented at a slower rate than this->max because once they reach a point of equivalence, this->max is doubled and bar() would be called, thus contributing to the overall runtime.
b) Amortized runtime for somefunc would be O(n) because the total runtime of somefunc would be O(n^2 + logn) due to bar's runtime being O(n^2), foo's runtime being O(logn). In order to calculate the amortized runtime, the sequence of operations is calculated thus the worst-case runtime should be divided by the number of times the function is run.
Since the value of this->n is increasing at a slower rate than max, the sequence of operations would occur n times. This would result in n^2 / n times which would give us the amortized runtime of O(n).
c) Amortized runtime for somefunc would be O(n) because the total runtime of somefunc would be O(n^2+nlogn). Although the runtime of foo is n times larger than before, the worst-case would still be O(n^2) and the sequence of operations would still occur n times as this->n is incremented by one while this->max is doubled once this->n and this->max are equivalent. Thus, the amortized runtime would be n^2/n = O(n).
d) Anotherfunc should be called after this->n equals this->max in somefunc. This would produce the worst sequence of calls because bar is called more frequently than foo in both functions which gives us the worst runtime. The amortized runtime of anotherfunc as a result of this sequence of calls, would be O(n) since it is called only when somefunc has produced equal values of this->n and this->max, thus the function operates n times. The amortized runtime of anotherfunc also be O(n) because it operates n times, calling both the bar and foo functions.